// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ApplicationScopeCategory {
    artifacts?: outputs.ApplicationScopeCategoryArtifact[];
    entityScopes?: outputs.ApplicationScopeCategoryEntityScope[];
    infrastructures?: outputs.ApplicationScopeCategoryInfrastructure[];
    workloads?: outputs.ApplicationScopeCategoryWorkload[];
}

export interface ApplicationScopeCategoryArtifact {
    cfs?: outputs.ApplicationScopeCategoryArtifactCf[];
    functions?: outputs.ApplicationScopeCategoryArtifactFunction[];
    images?: outputs.ApplicationScopeCategoryArtifactImage[];
}

export interface ApplicationScopeCategoryArtifactCf {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactCfVariable[];
}

export interface ApplicationScopeCategoryArtifactCfVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryArtifactFunction {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactFunctionVariable[];
}

export interface ApplicationScopeCategoryArtifactFunctionVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryArtifactImage {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactImageVariable[];
}

export interface ApplicationScopeCategoryArtifactImageVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryEntityScope {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryEntityScopeVariable[];
}

export interface ApplicationScopeCategoryEntityScopeVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryInfrastructure {
    kubernetes?: outputs.ApplicationScopeCategoryInfrastructureKubernete[];
    os?: outputs.ApplicationScopeCategoryInfrastructureO[];
}

export interface ApplicationScopeCategoryInfrastructureKubernete {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryInfrastructureKuberneteVariable[];
}

export interface ApplicationScopeCategoryInfrastructureKuberneteVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryInfrastructureO {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryInfrastructureOVariable[];
}

export interface ApplicationScopeCategoryInfrastructureOVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkload {
    cfs?: outputs.ApplicationScopeCategoryWorkloadCf[];
    kubernetes?: outputs.ApplicationScopeCategoryWorkloadKubernete[];
    os?: outputs.ApplicationScopeCategoryWorkloadO[];
}

export interface ApplicationScopeCategoryWorkloadCf {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadCfVariable[];
}

export interface ApplicationScopeCategoryWorkloadCfVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkloadKubernete {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadKuberneteVariable[];
}

export interface ApplicationScopeCategoryWorkloadKuberneteVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkloadO {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadOVariable[];
}

export interface ApplicationScopeCategoryWorkloadOVariable {
    attribute?: string;
    value?: string;
}

export interface AquasecHostRuntimePolicyFileIntegrityMonitoring {
    /**
     * List of paths to be excluded from being monitored.
     */
    excludedPaths?: string[];
    /**
     * List of processes to be excluded from being monitored.
     */
    excludedProcesses?: string[];
    /**
     * List of users to be excluded from being monitored.
     */
    excludedUsers?: string[];
    /**
     * If true, add attributes operations will be monitored.
     */
    monitorAttributes?: boolean;
    /**
     * If true, create operations will be monitored.
     */
    monitorCreate?: boolean;
    /**
     * If true, deletion operations will be monitored.
     */
    monitorDelete?: boolean;
    /**
     * If true, modification operations will be monitored.
     */
    monitorModify?: boolean;
    /**
     * If true, read operations will be monitored.
     */
    monitorRead?: boolean;
    /**
     * List of paths to be monitored.
     */
    monitoredPaths?: string[];
    /**
     * List of processes to be monitored.
     */
    monitoredProcesses?: string[];
    /**
     * List of users to be monitored.
     */
    monitoredUsers?: string[];
}

export interface AquasecHostRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface AquasecHostRuntimePolicyWindowsRegistryMonitoring {
    /**
     * List of paths to be excluded from being monitored.
     */
    excludedPaths?: string[];
    /**
     * List of registry processes to be excluded from being monitored.
     */
    excludedProcesses?: string[];
    /**
     * List of registry users to be excluded from being monitored.
     */
    excludedUsers?: string[];
    /**
     * If true, add attributes operations will be monitored.
     */
    monitorAttributes?: boolean;
    /**
     * If true, create operations will be monitored.
     */
    monitorCreate?: boolean;
    /**
     * If true, deletion operations will be monitored.
     */
    monitorDelete?: boolean;
    /**
     * If true, modification operations will be monitored.
     */
    monitorModify?: boolean;
    /**
     * If true, read operations will be monitored.
     */
    monitorRead?: boolean;
    /**
     * List of paths to be monitored.
     */
    monitoredPaths?: string[];
    /**
     * List of registry processes to be monitored.
     */
    monitoredProcesses?: string[];
    /**
     * List of registry users to be monitored.
     */
    monitoredUsers?: string[];
}

export interface AquasecHostRuntimePolicyWindowsRegistryProtection {
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludedPaths?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludedProcesses?: string[];
    /**
     * List of registry paths to be users from being protected.
     */
    excludedUsers?: string[];
    /**
     * List of registry paths to be protected.
     */
    protectedPaths?: string[];
    /**
     * List of registry processes to be protected.
     */
    protectedProcesses?: string[];
    /**
     * List of registry users to be protected.
     */
    protectedUsers?: string[];
}

export interface ContainerRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface EnforcerGroupsCommand {
    default: string;
    kubernetes: string;
    swarm: string;
    windows: string;
}

export interface EnforcerGroupsOrchestrator {
    master?: boolean;
    namespace?: string;
    serviceAccount?: string;
    type?: string;
}

export interface FirewallPolicyInboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to pass in data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource
     */
    resourceType: string;
}

export interface FirewallPolicyOutboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to receive data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource.
     */
    resourceType: string;
}

export interface FunctionAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface FunctionAssurancePolicyCustomCheck {
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface FunctionAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface FunctionAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface FunctionAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface FunctionAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface FunctionAssurancePolicyScope {
    expression: string;
    variables?: outputs.FunctionAssurancePolicyScopeVariable[];
}

export interface FunctionAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface FunctionAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface FunctionRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface GetApplicationScopeCategory {
    artifacts?: outputs.GetApplicationScopeCategoryArtifact[];
    entityScopes?: outputs.GetApplicationScopeCategoryEntityScope[];
    infrastructures?: outputs.GetApplicationScopeCategoryInfrastructure[];
    workloads?: outputs.GetApplicationScopeCategoryWorkload[];
}

export interface GetApplicationScopeCategoryArtifact {
    cfs?: outputs.GetApplicationScopeCategoryArtifactCf[];
    functions?: outputs.GetApplicationScopeCategoryArtifactFunction[];
    images?: outputs.GetApplicationScopeCategoryArtifactImage[];
}

export interface GetApplicationScopeCategoryArtifactCf {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactCfVariable[];
}

export interface GetApplicationScopeCategoryArtifactCfVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryArtifactFunction {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactFunctionVariable[];
}

export interface GetApplicationScopeCategoryArtifactFunctionVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryArtifactImage {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactImageVariable[];
}

export interface GetApplicationScopeCategoryArtifactImageVariable {
    attribute?: string;
    value?: string;
}

export interface GetApplicationScopeCategoryEntityScope {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryEntityScopeVariable[];
}

export interface GetApplicationScopeCategoryEntityScopeVariable {
    attribute: string;
    value: string;
}

export interface GetApplicationScopeCategoryInfrastructure {
    kubernetes?: outputs.GetApplicationScopeCategoryInfrastructureKubernete[];
    os?: outputs.GetApplicationScopeCategoryInfrastructureO[];
}

export interface GetApplicationScopeCategoryInfrastructureKubernete {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryInfrastructureKuberneteVariable[];
}

export interface GetApplicationScopeCategoryInfrastructureKuberneteVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryInfrastructureO {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryInfrastructureOVariable[];
}

export interface GetApplicationScopeCategoryInfrastructureOVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkload {
    cfs?: outputs.GetApplicationScopeCategoryWorkloadCf[];
    kubernetes?: outputs.GetApplicationScopeCategoryWorkloadKubernete[];
    os?: outputs.GetApplicationScopeCategoryWorkloadO[];
}

export interface GetApplicationScopeCategoryWorkloadCf {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadCfVariable[];
}

export interface GetApplicationScopeCategoryWorkloadCfVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkloadKubernete {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadKuberneteVariable[];
}

export interface GetApplicationScopeCategoryWorkloadKuberneteVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkloadO {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadOVariable[];
}

export interface GetApplicationScopeCategoryWorkloadOVariable {
    attribute: string;
    value?: string;
}

export interface GetContainerRuntimePolicyScopeVariable {
    attribute: string;
    value: string;
}

export interface GetEnforcerGroupsCommand {
    default: string;
    kubernetes: string;
    swarm: string;
    windows: string;
}

export interface GetEnforcerGroupsOrchestrator {
    master: boolean;
    namespace: string;
    serviceAccount: string;
    type: string;
}

export interface GetFirewallPolicyInboundNetwork {
    allow: boolean;
    portRange: string;
    resource: string;
    resourceType: string;
}

export interface GetFirewallPolicyOutboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to receive data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource.
     */
    resourceType: string;
}

export interface GetFunctionAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetFunctionAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetFunctionAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetFunctionAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetFunctionAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetFunctionAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetFunctionAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetFunctionAssurancePolicyScopeVariable[];
}

export interface GetFunctionAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetFunctionAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetFunctionRuntimePolicyScopeVariable {
    attribute: string;
    value: string;
}

export interface GetGatewaysGateway {
    description: string;
    grpcAddress: string;
    hostname: string;
    /**
     * The ID of this resource.
     */
    id: string;
    logicalname: string;
    publicAddress: string;
    status: string;
    version: string;
}

export interface GetGroupsGroup {
    created: string;
    groupId: string;
    name: string;
}

export interface GetHostAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetHostAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetHostAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetHostAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetHostAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetHostAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetHostAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetHostAssurancePolicyScopeVariable[];
}

export interface GetHostAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetHostAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetHostRuntimePolicyFileIntegrityMonitoring {
    excludedPaths: string[];
    excludedProcesses: string[];
    excludedUsers: string[];
    monitorAttributes: boolean;
    monitorCreate: boolean;
    monitorDelete: boolean;
    monitorModify: boolean;
    monitorRead: boolean;
    monitoredPaths: string[];
    monitoredProcesses: string[];
    monitoredUsers: string[];
}

export interface GetHostRuntimePolicyScopeVariable {
    attribute: string;
    value: string;
}

export interface GetHostRuntimePolicyWindowsRegistryMonitoring {
    excludedPaths: string[];
    excludedProcesses: string[];
    excludedUsers: string[];
    monitorAttributes: boolean;
    monitorCreate: boolean;
    monitorDelete: boolean;
    monitorModify: boolean;
    monitorRead: boolean;
    monitoredPaths: string[];
    monitoredProcesses: string[];
    monitoredUsers: string[];
}

export interface GetHostRuntimePolicyWindowsRegistryProtection {
    excludedPaths: string[];
    excludedProcesses: string[];
    excludedUsers: string[];
    protectedPaths: string[];
    protectedProcesses: string[];
    protectedUsers: string[];
}

export interface GetImageAssuranceChecksPerformed {
    assuranceType: string;
    blocking: boolean;
    control: string;
    /**
     * If DTA was skipped.
     */
    dtaSkipped: boolean;
    /**
     * The reason why DTA was skipped.
     */
    dtaSkippedReason: string;
    failed: boolean;
    policyName: string;
}

export interface GetImageAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetImageAssurancePolicyCustomCheck {
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetImageAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetImageAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetImageAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetImageAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetImageAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetImageAssurancePolicyScopeVariable[];
}

export interface GetImageAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetImageAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetImageHistory {
    /**
     * The image creation comment.
     */
    comment: string;
    /**
     * The date and time when the image was registered.
     */
    created: string;
    createdBy: string;
    /**
     * The ID of this resource.
     */
    id: string;
    size: number;
}

export interface GetImageVulnerability {
    ackAuthor: string;
    ackComment: string;
    ackExpirationConfiguredAt: string;
    ackExpirationConfiguredBy: string;
    ackExpirationDays: number;
    ackScope: string;
    acknowledgeDate: string;
    ancestorPkg: string;
    aquaScore: number;
    aquaScoreClassification: string;
    aquaScoringSystem: string;
    aquaSeverity: string;
    aquaSeverityClassification: string;
    aquaVectors: string;
    auditEventsCount: number;
    blockEventsCount: number;
    classification: string;
    description: string;
    /**
     * The content digest of the image.
     */
    digest: string;
    exploitReference: string;
    exploitType: string;
    firstFoundDate: string;
    fixVersion: string;
    imageName: string;
    lastFoundDate: string;
    modificationDate: string;
    /**
     * The name of the image.
     */
    name: string;
    nvdCvss2Score: number;
    nvdCvss2Vectors: string;
    nvdCvss3Score: number;
    nvdCvss3Severity: string;
    nvdCvss3Vectors: string;
    nvdSeverity: string;
    nvdUrl: string;
    /**
     * The operating system detected in the image
     */
    os: string;
    /**
     * The version of the OS detected in the image.
     */
    osVersion: string;
    /**
     * Permission of the image.
     */
    permission: string;
    publishDate: string;
    /**
     * The name of the registry where the image is stored.
     */
    registry: string;
    /**
     * The name of the image's repository.
     */
    repository: string;
    resourceArchitecture: string;
    resourceCpe: string;
    resourceFormat: string;
    resourceHash: string;
    resourceLicenses: string[];
    resourceName: string;
    resourcePath: string;
    resourceType: string;
    resourceVersion: string;
    severityClassification: string;
    solution: string;
    temporalVector: string;
    vPatchAppliedBy: string;
    vPatchAppliedOn: string;
    vPatchEnforcedBy: string;
    vPatchEnforcedOn: string;
    vPatchPolicyEnforce: boolean;
    vPatchPolicyName: string;
    vPatchRevertedBy: string;
    vPatchRevertedOn: string;
    vPatchStatus: string;
    vendorCvss2Score: number;
    vendorCvss2Vectors: string;
    vendorSeverity: string;
    vendorStatement: string;
    vendorUrl: string;
}

export interface GetPermissionsSetsPermissionsSet {
    actions: string[];
    author: string;
    description: string;
    isSuper: boolean;
    name: string;
    uiAccess: boolean;
    updatedAt: string;
}

export interface GetRolesRole {
    description: string;
    name: string;
    permission: string;
    scopes: string[];
    updatedAt: string;
}

export interface GetServiceScopeVariable {
    attribute: string;
    value: string;
}

export interface GetUsersSaasUser {
    accountAdmin: boolean;
    confirmed: boolean;
    created: string;
    cspRoles: string[];
    dashboard: boolean;
    email: string;
    groups: outputs.GetUsersSaasUserGroup[];
    logins: outputs.GetUsersSaasUserLogin[];
    multiaccount: boolean;
    passwordReset: boolean;
    provider: string;
    sendAnnouncements: boolean;
    sendNewPlugins: boolean;
    sendNewRisks: boolean;
    sendScanResults: boolean;
    userId: string;
}

export interface GetUsersSaasUserGroup {
    created: string;
    /**
     * The ID of this resource.
     */
    id: number;
    name: string;
}

export interface GetUsersSaasUserLogin {
    created: string;
    /**
     * The ID of this resource.
     */
    id: number;
    ipAddress: string;
    userId: number;
}

export interface GetUsersUser {
    email: string;
    firstTime: boolean;
    isSuper: boolean;
    name: string;
    plan: string;
    role: string;
    roles: string[];
    type: string;
    uiAccess: boolean;
    userId: string;
}

export interface HostAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface HostAssurancePolicyCustomCheck {
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface HostAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface HostAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface HostAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface HostAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface HostAssurancePolicyScope {
    expression: string;
    variables?: outputs.HostAssurancePolicyScopeVariable[];
}

export interface HostAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface HostAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface ImageAssuranceChecksPerformed {
    assuranceType: string;
    blocking: boolean;
    control: string;
    /**
     * If DTA was skipped.
     */
    dtaSkipped: boolean;
    /**
     * The reason why DTA was skipped.
     */
    dtaSkippedReason: string;
    failed: boolean;
    policyName: string;
}

export interface ImageAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface ImageAssurancePolicyCustomCheck {
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface ImageAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface ImageAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface ImageAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface ImageAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface ImageAssurancePolicyScope {
    expression: string;
    variables?: outputs.ImageAssurancePolicyScopeVariable[];
}

export interface ImageAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface ImageAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface ImageHistory {
    /**
     * The image creation comment.
     */
    comment: string;
    /**
     * The date and time when the image was registered.
     */
    created: string;
    createdBy: string;
    /**
     * The ID of this resource.
     */
    id: string;
    size: number;
}

export interface ImageVulnerability {
    ackAuthor: string;
    ackComment: string;
    ackExpirationConfiguredAt: string;
    ackExpirationConfiguredBy: string;
    ackExpirationDays: number;
    ackScope: string;
    acknowledgeDate: string;
    ancestorPkg: string;
    aquaScore: number;
    aquaScoreClassification: string;
    aquaScoringSystem: string;
    aquaSeverity: string;
    aquaSeverityClassification: string;
    aquaVectors: string;
    auditEventsCount: number;
    blockEventsCount: number;
    classification: string;
    description: string;
    /**
     * The content digest of the image.
     */
    digest: string;
    exploitReference: string;
    exploitType: string;
    firstFoundDate: string;
    fixVersion: string;
    imageName: string;
    lastFoundDate: string;
    modificationDate: string;
    /**
     * The name of the image.
     */
    name: string;
    nvdCvss2Score: number;
    nvdCvss2Vectors: string;
    nvdCvss3Score: number;
    nvdCvss3Severity: string;
    nvdCvss3Vectors: string;
    nvdSeverity: string;
    nvdUrl: string;
    /**
     * The operating system detected in the image
     */
    os: string;
    /**
     * The version of the OS detected in the image.
     */
    osVersion: string;
    /**
     * Permission of the image.
     */
    permission: string;
    publishDate: string;
    /**
     * The name of the registry where the image is stored.
     */
    registry: string;
    /**
     * The name of the image's repository.
     */
    repository: string;
    resourceArchitecture: string;
    resourceCpe: string;
    resourceFormat: string;
    resourceHash: string;
    resourceLicenses: string[];
    resourceName: string;
    resourcePath: string;
    resourceType: string;
    resourceVersion: string;
    severityClassification: string;
    solution: string;
    temporalVector: string;
    vPatchAppliedBy: string;
    vPatchAppliedOn: string;
    vPatchEnforcedBy: string;
    vPatchEnforcedOn: string;
    vPatchPolicyEnforce: boolean;
    vPatchPolicyName: string;
    vPatchRevertedBy: string;
    vPatchRevertedOn: string;
    vPatchStatus: string;
    vendorCvss2Score: number;
    vendorCvss2Vectors: string;
    vendorSeverity: string;
    vendorStatement: string;
    vendorUrl: string;
}

export interface ServiceScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface UserSaasGroup {
    groupAdmin?: boolean;
    name?: string;
}

export interface UserSaasLogin {
    created: string;
    /**
     * The ID of this resource.
     */
    id: number;
    ipAddress: string;
    userId: number;
}

