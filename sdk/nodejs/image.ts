// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "./types";
import * as utilities from "./utilities";

export class Image extends pulumi.CustomResource {
    /**
     * Get an existing Image resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ImageState, opts?: pulumi.CustomResourceOptions): Image {
        return new Image(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'aquasec:index/image:Image';

    /**
     * Returns true if the given object is an instance of Image.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Image {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Image.__pulumiType;
    }

    /**
     * If this field is set to true, the image will be whitelisted.
     */
    public readonly allowImage!: pulumi.Output<boolean | undefined>;
    /**
     * The image architecture.
     */
    public /*out*/ readonly architecture!: pulumi.Output<string>;
    /**
     * The list of image assurance checks performed on the image.
     */
    public /*out*/ readonly assuranceChecksPerformeds!: pulumi.Output<outputs.ImageAssuranceChecksPerformed[]>;
    /**
     * The name of the user who registered the image.
     */
    public /*out*/ readonly author!: pulumi.Output<string>;
    /**
     * Whether the image is blacklisted.
     */
    public /*out*/ readonly blacklisted!: pulumi.Output<boolean>;
    /**
     * If this field is set to true, the image will be blacklisted.
     */
    public readonly blockImage!: pulumi.Output<boolean | undefined>;
    /**
     * The image creation comment.
     */
    public /*out*/ readonly comment!: pulumi.Output<string>;
    /**
     * The date and time when the image was registered.
     */
    public /*out*/ readonly created!: pulumi.Output<string>;
    /**
     * Number of critical severity vulnerabilities detected in the image.
     */
    public /*out*/ readonly criticalVulnerabilities!: pulumi.Output<number>;
    /**
     * The default user of the image.
     */
    public /*out*/ readonly defaultUser!: pulumi.Output<string>;
    /**
     * The content digest of the image.
     */
    public /*out*/ readonly digest!: pulumi.Output<string>;
    /**
     * Whether the image is disallowed (non-compliant).
     */
    public /*out*/ readonly disallowed!: pulumi.Output<boolean>;
    /**
     * Whether the image was disallowed because of Image Assurance Policies.
     */
    public /*out*/ readonly disallowedByAssuranceChecks!: pulumi.Output<boolean>;
    /**
     * The Docker image ID.
     */
    public /*out*/ readonly dockerId!: pulumi.Output<string>;
    /**
     * Docker labels of the image.
     */
    public /*out*/ readonly dockerLabels!: pulumi.Output<string[]>;
    /**
     * The Docker version used when building the image.
     */
    public /*out*/ readonly dockerVersion!: pulumi.Output<string>;
    /**
     * DTA severity score.
     */
    public /*out*/ readonly dtaSeverityScore!: pulumi.Output<string>;
    /**
     * If DTA was skipped.
     */
    public /*out*/ readonly dtaSkipped!: pulumi.Output<boolean>;
    /**
     * The reason why DTA was skipped.
     */
    public /*out*/ readonly dtaSkippedReason!: pulumi.Output<string>;
    /**
     * Environment variables in the image.
     */
    public /*out*/ readonly environmentVariables!: pulumi.Output<string[]>;
    /**
     * Number of high severity vulnerabilities detected in the image.
     */
    public /*out*/ readonly highVulnerabilities!: pulumi.Output<number>;
    /**
     * The Docker history of the image.
     */
    public /*out*/ readonly histories!: pulumi.Output<outputs.ImageHistory[]>;
    /**
     * The size of the image in bytes.
     */
    public /*out*/ readonly imageSize!: pulumi.Output<number>;
    /**
     * The type of the image.
     */
    public /*out*/ readonly imageType!: pulumi.Output<string>;
    /**
     * Aqua labels of the image.
     */
    public /*out*/ readonly labels!: pulumi.Output<string[]>;
    /**
     * Number of low severity vulnerabilities detected in the image.
     */
    public /*out*/ readonly lowVulnerabilities!: pulumi.Output<number>;
    /**
     * Number of malware found on the image.
     */
    public /*out*/ readonly malware!: pulumi.Output<number>;
    /**
     * Number of medium severity vulnerabilities detected in the image.
     */
    public /*out*/ readonly mediumVulnerabilities!: pulumi.Output<number>;
    /**
     * The name of the image.
     */
    public /*out*/ readonly name!: pulumi.Output<string>;
    /**
     * Number of negligible severity vulnerabilities detected in the image.
     */
    public /*out*/ readonly negligibleVulnerabilities!: pulumi.Output<number>;
    /**
     * Whether a new version of the image is available in the registry but is not scanned and registered yet.
     */
    public /*out*/ readonly newerImageExists!: pulumi.Output<boolean>;
    /**
     * The operating system detected in the image
     */
    public /*out*/ readonly os!: pulumi.Output<string>;
    /**
     * The version of the OS detected in the image.
     */
    public /*out*/ readonly osVersion!: pulumi.Output<string>;
    /**
     * The ID of the parent image.
     */
    public /*out*/ readonly parent!: pulumi.Output<string>;
    /**
     * Whether the image could only be partially scanned.
     */
    public /*out*/ readonly partialResults!: pulumi.Output<boolean>;
    /**
     * Whether the image is non-compliant, but is pending this status due to running containers.
     */
    public /*out*/ readonly pendingDisallowed!: pulumi.Output<boolean>;
    /**
     * Permission of the image.
     */
    public /*out*/ readonly permission!: pulumi.Output<string>;
    /**
     * The name of the user who last modified the image permissions.
     */
    public /*out*/ readonly permissionAuthor!: pulumi.Output<string>;
    /**
     * The comment provided when the image permissions were last modified
     */
    public /*out*/ readonly permissionComment!: pulumi.Output<string>;
    /**
     * A comment on why the image was whitelisted or blacklisted
     */
    public readonly permissionModificationComment!: pulumi.Output<string | undefined>;
    /**
     * The name of the registry where the image is stored.
     */
    public readonly registry!: pulumi.Output<string>;
    /**
     * Type of the registry.
     */
    public /*out*/ readonly registryType!: pulumi.Output<string>;
    /**
     * The repository digests.
     */
    public /*out*/ readonly repoDigests!: pulumi.Output<string[]>;
    /**
     * The name of the image's repository.
     */
    public readonly repository!: pulumi.Output<string>;
    /**
     * The date and time when the image was last scanned.
     */
    public /*out*/ readonly scanDate!: pulumi.Output<string>;
    /**
     * If the image scan failed, the failure message.
     */
    public /*out*/ readonly scanError!: pulumi.Output<string>;
    /**
     * The scan status of the image (either 'pending', 'in*progress', 'finished', 'failed' or 'not*started').
     */
    public /*out*/ readonly scanStatus!: pulumi.Output<string>;
    /**
     * Number of sensitive data detected in the image.
     */
    public /*out*/ readonly sensitiveData!: pulumi.Output<number>;
    /**
     * The tag of the image.
     */
    public readonly tag!: pulumi.Output<string>;
    /**
     * The total number of vulnerabilities detected in the image.
     */
    public /*out*/ readonly totalVulnerabilities!: pulumi.Output<number>;
    /**
     * The virtual size of the image.
     */
    public /*out*/ readonly virtualSize!: pulumi.Output<number>;
    /**
     * A list of all the vulnerabilities found in the image
     */
    public /*out*/ readonly vulnerabilities!: pulumi.Output<outputs.ImageVulnerability[]>;
    /**
     * Whether the image is whitelisted.
     */
    public /*out*/ readonly whitelisted!: pulumi.Output<boolean>;

    /**
     * Create a Image resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ImageArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ImageArgs | ImageState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ImageState | undefined;
            resourceInputs["allowImage"] = state ? state.allowImage : undefined;
            resourceInputs["architecture"] = state ? state.architecture : undefined;
            resourceInputs["assuranceChecksPerformeds"] = state ? state.assuranceChecksPerformeds : undefined;
            resourceInputs["author"] = state ? state.author : undefined;
            resourceInputs["blacklisted"] = state ? state.blacklisted : undefined;
            resourceInputs["blockImage"] = state ? state.blockImage : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["created"] = state ? state.created : undefined;
            resourceInputs["criticalVulnerabilities"] = state ? state.criticalVulnerabilities : undefined;
            resourceInputs["defaultUser"] = state ? state.defaultUser : undefined;
            resourceInputs["digest"] = state ? state.digest : undefined;
            resourceInputs["disallowed"] = state ? state.disallowed : undefined;
            resourceInputs["disallowedByAssuranceChecks"] = state ? state.disallowedByAssuranceChecks : undefined;
            resourceInputs["dockerId"] = state ? state.dockerId : undefined;
            resourceInputs["dockerLabels"] = state ? state.dockerLabels : undefined;
            resourceInputs["dockerVersion"] = state ? state.dockerVersion : undefined;
            resourceInputs["dtaSeverityScore"] = state ? state.dtaSeverityScore : undefined;
            resourceInputs["dtaSkipped"] = state ? state.dtaSkipped : undefined;
            resourceInputs["dtaSkippedReason"] = state ? state.dtaSkippedReason : undefined;
            resourceInputs["environmentVariables"] = state ? state.environmentVariables : undefined;
            resourceInputs["highVulnerabilities"] = state ? state.highVulnerabilities : undefined;
            resourceInputs["histories"] = state ? state.histories : undefined;
            resourceInputs["imageSize"] = state ? state.imageSize : undefined;
            resourceInputs["imageType"] = state ? state.imageType : undefined;
            resourceInputs["labels"] = state ? state.labels : undefined;
            resourceInputs["lowVulnerabilities"] = state ? state.lowVulnerabilities : undefined;
            resourceInputs["malware"] = state ? state.malware : undefined;
            resourceInputs["mediumVulnerabilities"] = state ? state.mediumVulnerabilities : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["negligibleVulnerabilities"] = state ? state.negligibleVulnerabilities : undefined;
            resourceInputs["newerImageExists"] = state ? state.newerImageExists : undefined;
            resourceInputs["os"] = state ? state.os : undefined;
            resourceInputs["osVersion"] = state ? state.osVersion : undefined;
            resourceInputs["parent"] = state ? state.parent : undefined;
            resourceInputs["partialResults"] = state ? state.partialResults : undefined;
            resourceInputs["pendingDisallowed"] = state ? state.pendingDisallowed : undefined;
            resourceInputs["permission"] = state ? state.permission : undefined;
            resourceInputs["permissionAuthor"] = state ? state.permissionAuthor : undefined;
            resourceInputs["permissionComment"] = state ? state.permissionComment : undefined;
            resourceInputs["permissionModificationComment"] = state ? state.permissionModificationComment : undefined;
            resourceInputs["registry"] = state ? state.registry : undefined;
            resourceInputs["registryType"] = state ? state.registryType : undefined;
            resourceInputs["repoDigests"] = state ? state.repoDigests : undefined;
            resourceInputs["repository"] = state ? state.repository : undefined;
            resourceInputs["scanDate"] = state ? state.scanDate : undefined;
            resourceInputs["scanError"] = state ? state.scanError : undefined;
            resourceInputs["scanStatus"] = state ? state.scanStatus : undefined;
            resourceInputs["sensitiveData"] = state ? state.sensitiveData : undefined;
            resourceInputs["tag"] = state ? state.tag : undefined;
            resourceInputs["totalVulnerabilities"] = state ? state.totalVulnerabilities : undefined;
            resourceInputs["virtualSize"] = state ? state.virtualSize : undefined;
            resourceInputs["vulnerabilities"] = state ? state.vulnerabilities : undefined;
            resourceInputs["whitelisted"] = state ? state.whitelisted : undefined;
        } else {
            const args = argsOrState as ImageArgs | undefined;
            if ((!args || args.registry === undefined) && !opts.urn) {
                throw new Error("Missing required property 'registry'");
            }
            if ((!args || args.repository === undefined) && !opts.urn) {
                throw new Error("Missing required property 'repository'");
            }
            if ((!args || args.tag === undefined) && !opts.urn) {
                throw new Error("Missing required property 'tag'");
            }
            resourceInputs["allowImage"] = args ? args.allowImage : undefined;
            resourceInputs["blockImage"] = args ? args.blockImage : undefined;
            resourceInputs["permissionModificationComment"] = args ? args.permissionModificationComment : undefined;
            resourceInputs["registry"] = args ? args.registry : undefined;
            resourceInputs["repository"] = args ? args.repository : undefined;
            resourceInputs["tag"] = args ? args.tag : undefined;
            resourceInputs["architecture"] = undefined /*out*/;
            resourceInputs["assuranceChecksPerformeds"] = undefined /*out*/;
            resourceInputs["author"] = undefined /*out*/;
            resourceInputs["blacklisted"] = undefined /*out*/;
            resourceInputs["comment"] = undefined /*out*/;
            resourceInputs["created"] = undefined /*out*/;
            resourceInputs["criticalVulnerabilities"] = undefined /*out*/;
            resourceInputs["defaultUser"] = undefined /*out*/;
            resourceInputs["digest"] = undefined /*out*/;
            resourceInputs["disallowed"] = undefined /*out*/;
            resourceInputs["disallowedByAssuranceChecks"] = undefined /*out*/;
            resourceInputs["dockerId"] = undefined /*out*/;
            resourceInputs["dockerLabels"] = undefined /*out*/;
            resourceInputs["dockerVersion"] = undefined /*out*/;
            resourceInputs["dtaSeverityScore"] = undefined /*out*/;
            resourceInputs["dtaSkipped"] = undefined /*out*/;
            resourceInputs["dtaSkippedReason"] = undefined /*out*/;
            resourceInputs["environmentVariables"] = undefined /*out*/;
            resourceInputs["highVulnerabilities"] = undefined /*out*/;
            resourceInputs["histories"] = undefined /*out*/;
            resourceInputs["imageSize"] = undefined /*out*/;
            resourceInputs["imageType"] = undefined /*out*/;
            resourceInputs["labels"] = undefined /*out*/;
            resourceInputs["lowVulnerabilities"] = undefined /*out*/;
            resourceInputs["malware"] = undefined /*out*/;
            resourceInputs["mediumVulnerabilities"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["negligibleVulnerabilities"] = undefined /*out*/;
            resourceInputs["newerImageExists"] = undefined /*out*/;
            resourceInputs["os"] = undefined /*out*/;
            resourceInputs["osVersion"] = undefined /*out*/;
            resourceInputs["parent"] = undefined /*out*/;
            resourceInputs["partialResults"] = undefined /*out*/;
            resourceInputs["pendingDisallowed"] = undefined /*out*/;
            resourceInputs["permission"] = undefined /*out*/;
            resourceInputs["permissionAuthor"] = undefined /*out*/;
            resourceInputs["permissionComment"] = undefined /*out*/;
            resourceInputs["registryType"] = undefined /*out*/;
            resourceInputs["repoDigests"] = undefined /*out*/;
            resourceInputs["scanDate"] = undefined /*out*/;
            resourceInputs["scanError"] = undefined /*out*/;
            resourceInputs["scanStatus"] = undefined /*out*/;
            resourceInputs["sensitiveData"] = undefined /*out*/;
            resourceInputs["totalVulnerabilities"] = undefined /*out*/;
            resourceInputs["virtualSize"] = undefined /*out*/;
            resourceInputs["vulnerabilities"] = undefined /*out*/;
            resourceInputs["whitelisted"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Image.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Image resources.
 */
export interface ImageState {
    /**
     * If this field is set to true, the image will be whitelisted.
     */
    allowImage?: pulumi.Input<boolean>;
    /**
     * The image architecture.
     */
    architecture?: pulumi.Input<string>;
    /**
     * The list of image assurance checks performed on the image.
     */
    assuranceChecksPerformeds?: pulumi.Input<pulumi.Input<inputs.ImageAssuranceChecksPerformed>[]>;
    /**
     * The name of the user who registered the image.
     */
    author?: pulumi.Input<string>;
    /**
     * Whether the image is blacklisted.
     */
    blacklisted?: pulumi.Input<boolean>;
    /**
     * If this field is set to true, the image will be blacklisted.
     */
    blockImage?: pulumi.Input<boolean>;
    /**
     * The image creation comment.
     */
    comment?: pulumi.Input<string>;
    /**
     * The date and time when the image was registered.
     */
    created?: pulumi.Input<string>;
    /**
     * Number of critical severity vulnerabilities detected in the image.
     */
    criticalVulnerabilities?: pulumi.Input<number>;
    /**
     * The default user of the image.
     */
    defaultUser?: pulumi.Input<string>;
    /**
     * The content digest of the image.
     */
    digest?: pulumi.Input<string>;
    /**
     * Whether the image is disallowed (non-compliant).
     */
    disallowed?: pulumi.Input<boolean>;
    /**
     * Whether the image was disallowed because of Image Assurance Policies.
     */
    disallowedByAssuranceChecks?: pulumi.Input<boolean>;
    /**
     * The Docker image ID.
     */
    dockerId?: pulumi.Input<string>;
    /**
     * Docker labels of the image.
     */
    dockerLabels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Docker version used when building the image.
     */
    dockerVersion?: pulumi.Input<string>;
    /**
     * DTA severity score.
     */
    dtaSeverityScore?: pulumi.Input<string>;
    /**
     * If DTA was skipped.
     */
    dtaSkipped?: pulumi.Input<boolean>;
    /**
     * The reason why DTA was skipped.
     */
    dtaSkippedReason?: pulumi.Input<string>;
    /**
     * Environment variables in the image.
     */
    environmentVariables?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Number of high severity vulnerabilities detected in the image.
     */
    highVulnerabilities?: pulumi.Input<number>;
    /**
     * The Docker history of the image.
     */
    histories?: pulumi.Input<pulumi.Input<inputs.ImageHistory>[]>;
    /**
     * The size of the image in bytes.
     */
    imageSize?: pulumi.Input<number>;
    /**
     * The type of the image.
     */
    imageType?: pulumi.Input<string>;
    /**
     * Aqua labels of the image.
     */
    labels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Number of low severity vulnerabilities detected in the image.
     */
    lowVulnerabilities?: pulumi.Input<number>;
    /**
     * Number of malware found on the image.
     */
    malware?: pulumi.Input<number>;
    /**
     * Number of medium severity vulnerabilities detected in the image.
     */
    mediumVulnerabilities?: pulumi.Input<number>;
    /**
     * The name of the image.
     */
    name?: pulumi.Input<string>;
    /**
     * Number of negligible severity vulnerabilities detected in the image.
     */
    negligibleVulnerabilities?: pulumi.Input<number>;
    /**
     * Whether a new version of the image is available in the registry but is not scanned and registered yet.
     */
    newerImageExists?: pulumi.Input<boolean>;
    /**
     * The operating system detected in the image
     */
    os?: pulumi.Input<string>;
    /**
     * The version of the OS detected in the image.
     */
    osVersion?: pulumi.Input<string>;
    /**
     * The ID of the parent image.
     */
    parent?: pulumi.Input<string>;
    /**
     * Whether the image could only be partially scanned.
     */
    partialResults?: pulumi.Input<boolean>;
    /**
     * Whether the image is non-compliant, but is pending this status due to running containers.
     */
    pendingDisallowed?: pulumi.Input<boolean>;
    /**
     * Permission of the image.
     */
    permission?: pulumi.Input<string>;
    /**
     * The name of the user who last modified the image permissions.
     */
    permissionAuthor?: pulumi.Input<string>;
    /**
     * The comment provided when the image permissions were last modified
     */
    permissionComment?: pulumi.Input<string>;
    /**
     * A comment on why the image was whitelisted or blacklisted
     */
    permissionModificationComment?: pulumi.Input<string>;
    /**
     * The name of the registry where the image is stored.
     */
    registry?: pulumi.Input<string>;
    /**
     * Type of the registry.
     */
    registryType?: pulumi.Input<string>;
    /**
     * The repository digests.
     */
    repoDigests?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the image's repository.
     */
    repository?: pulumi.Input<string>;
    /**
     * The date and time when the image was last scanned.
     */
    scanDate?: pulumi.Input<string>;
    /**
     * If the image scan failed, the failure message.
     */
    scanError?: pulumi.Input<string>;
    /**
     * The scan status of the image (either 'pending', 'in*progress', 'finished', 'failed' or 'not*started').
     */
    scanStatus?: pulumi.Input<string>;
    /**
     * Number of sensitive data detected in the image.
     */
    sensitiveData?: pulumi.Input<number>;
    /**
     * The tag of the image.
     */
    tag?: pulumi.Input<string>;
    /**
     * The total number of vulnerabilities detected in the image.
     */
    totalVulnerabilities?: pulumi.Input<number>;
    /**
     * The virtual size of the image.
     */
    virtualSize?: pulumi.Input<number>;
    /**
     * A list of all the vulnerabilities found in the image
     */
    vulnerabilities?: pulumi.Input<pulumi.Input<inputs.ImageVulnerability>[]>;
    /**
     * Whether the image is whitelisted.
     */
    whitelisted?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a Image resource.
 */
export interface ImageArgs {
    /**
     * If this field is set to true, the image will be whitelisted.
     */
    allowImage?: pulumi.Input<boolean>;
    /**
     * If this field is set to true, the image will be blacklisted.
     */
    blockImage?: pulumi.Input<boolean>;
    /**
     * A comment on why the image was whitelisted or blacklisted
     */
    permissionModificationComment?: pulumi.Input<string>;
    /**
     * The name of the registry where the image is stored.
     */
    registry: pulumi.Input<string>;
    /**
     * The name of the image's repository.
     */
    repository: pulumi.Input<string>;
    /**
     * The tag of the image.
     */
    tag: pulumi.Input<string>;
}
