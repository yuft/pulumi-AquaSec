// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package aquasec

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-aquasec/sdk/go/aquasec"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := aquasec.NewApplicationScope(ctx, "terraformiap", &aquasec.ApplicationScopeArgs{
// 			Categories: ApplicationScopeCategoryArray{
// 				&ApplicationScopeCategoryArgs{
// 					Artifacts: ApplicationScopeCategoryArtifactArray{
// 						&ApplicationScopeCategoryArtifactArgs{
// 							Image: []map[string]interface{}{
// 								map[string]interface{}{
// 									"expression": "v1 && v2",
// 									"variables": []map[string]interface{}{
// 										map[string]interface{}{
// 											"attribute": "aqua.registry",
// 											"value":     "test-registry",
// 										},
// 										map[string]interface{}{
// 											"attribute": "image.repo",
// 											"value":     "nginx",
// 										},
// 									},
// 								},
// 							},
// 						},
// 					},
// 					Infrastructures: ApplicationScopeCategoryInfrastructureArray{
// 						&ApplicationScopeCategoryInfrastructureArgs{
// 							Kubernetes: ApplicationScopeCategoryInfrastructureKuberneteArray{
// 								&ApplicationScopeCategoryInfrastructureKuberneteArgs{
// 									Expression: pulumi.String("v1"),
// 									Variables: ApplicationScopeCategoryInfrastructureKuberneteVariableArray{
// 										&ApplicationScopeCategoryInfrastructureKuberneteVariableArgs{
// 											Attribute: pulumi.String("kubernetes.cluster"),
// 											Value:     pulumi.String("aqua"),
// 										},
// 									},
// 								},
// 							},
// 						},
// 					},
// 					Workloads: ApplicationScopeCategoryWorkloadArray{
// 						&ApplicationScopeCategoryWorkloadArgs{
// 							Kubernetes: ApplicationScopeCategoryWorkloadKuberneteArray{
// 								&ApplicationScopeCategoryWorkloadKuberneteArgs{
// 									Expression: pulumi.String("v1 && v2"),
// 									Variables: ApplicationScopeCategoryWorkloadKuberneteVariableArray{
// 										&ApplicationScopeCategoryWorkloadKuberneteVariableArgs{
// 											Attribute: pulumi.String("kubernetes.cluster"),
// 											Value:     pulumi.String("aqua"),
// 										},
// 										&ApplicationScopeCategoryWorkloadKuberneteVariableArgs{
// 											Attribute: pulumi.String("kubernetes.namespace"),
// 											Value:     pulumi.String("aqua"),
// 										},
// 									},
// 								},
// 							},
// 						},
// 					},
// 				},
// 			},
// 			Description: pulumi.String("test123"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type ApplicationScope struct {
	pulumi.CustomResourceState

	Author      pulumi.StringOutput                 `pulumi:"author"`
	Categories  ApplicationScopeCategoryArrayOutput `pulumi:"categories"`
	Description pulumi.StringPtrOutput              `pulumi:"description"`
	Name        pulumi.StringOutput                 `pulumi:"name"`
	OwnerEmail  pulumi.StringPtrOutput              `pulumi:"ownerEmail"`
}

// NewApplicationScope registers a new resource with the given unique name, arguments, and options.
func NewApplicationScope(ctx *pulumi.Context,
	name string, args *ApplicationScopeArgs, opts ...pulumi.ResourceOption) (*ApplicationScope, error) {
	if args == nil {
		args = &ApplicationScopeArgs{}
	}

	var resource ApplicationScope
	err := ctx.RegisterResource("aquasec:index/applicationScope:ApplicationScope", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApplicationScope gets an existing ApplicationScope resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApplicationScope(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApplicationScopeState, opts ...pulumi.ResourceOption) (*ApplicationScope, error) {
	var resource ApplicationScope
	err := ctx.ReadResource("aquasec:index/applicationScope:ApplicationScope", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApplicationScope resources.
type applicationScopeState struct {
	Author      *string                    `pulumi:"author"`
	Categories  []ApplicationScopeCategory `pulumi:"categories"`
	Description *string                    `pulumi:"description"`
	Name        *string                    `pulumi:"name"`
	OwnerEmail  *string                    `pulumi:"ownerEmail"`
}

type ApplicationScopeState struct {
	Author      pulumi.StringPtrInput
	Categories  ApplicationScopeCategoryArrayInput
	Description pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	OwnerEmail  pulumi.StringPtrInput
}

func (ApplicationScopeState) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationScopeState)(nil)).Elem()
}

type applicationScopeArgs struct {
	Categories  []ApplicationScopeCategory `pulumi:"categories"`
	Description *string                    `pulumi:"description"`
	Name        *string                    `pulumi:"name"`
	OwnerEmail  *string                    `pulumi:"ownerEmail"`
}

// The set of arguments for constructing a ApplicationScope resource.
type ApplicationScopeArgs struct {
	Categories  ApplicationScopeCategoryArrayInput
	Description pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	OwnerEmail  pulumi.StringPtrInput
}

func (ApplicationScopeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationScopeArgs)(nil)).Elem()
}

type ApplicationScopeInput interface {
	pulumi.Input

	ToApplicationScopeOutput() ApplicationScopeOutput
	ToApplicationScopeOutputWithContext(ctx context.Context) ApplicationScopeOutput
}

func (*ApplicationScope) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationScope)(nil)).Elem()
}

func (i *ApplicationScope) ToApplicationScopeOutput() ApplicationScopeOutput {
	return i.ToApplicationScopeOutputWithContext(context.Background())
}

func (i *ApplicationScope) ToApplicationScopeOutputWithContext(ctx context.Context) ApplicationScopeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationScopeOutput)
}

// ApplicationScopeArrayInput is an input type that accepts ApplicationScopeArray and ApplicationScopeArrayOutput values.
// You can construct a concrete instance of `ApplicationScopeArrayInput` via:
//
//          ApplicationScopeArray{ ApplicationScopeArgs{...} }
type ApplicationScopeArrayInput interface {
	pulumi.Input

	ToApplicationScopeArrayOutput() ApplicationScopeArrayOutput
	ToApplicationScopeArrayOutputWithContext(context.Context) ApplicationScopeArrayOutput
}

type ApplicationScopeArray []ApplicationScopeInput

func (ApplicationScopeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationScope)(nil)).Elem()
}

func (i ApplicationScopeArray) ToApplicationScopeArrayOutput() ApplicationScopeArrayOutput {
	return i.ToApplicationScopeArrayOutputWithContext(context.Background())
}

func (i ApplicationScopeArray) ToApplicationScopeArrayOutputWithContext(ctx context.Context) ApplicationScopeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationScopeArrayOutput)
}

// ApplicationScopeMapInput is an input type that accepts ApplicationScopeMap and ApplicationScopeMapOutput values.
// You can construct a concrete instance of `ApplicationScopeMapInput` via:
//
//          ApplicationScopeMap{ "key": ApplicationScopeArgs{...} }
type ApplicationScopeMapInput interface {
	pulumi.Input

	ToApplicationScopeMapOutput() ApplicationScopeMapOutput
	ToApplicationScopeMapOutputWithContext(context.Context) ApplicationScopeMapOutput
}

type ApplicationScopeMap map[string]ApplicationScopeInput

func (ApplicationScopeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationScope)(nil)).Elem()
}

func (i ApplicationScopeMap) ToApplicationScopeMapOutput() ApplicationScopeMapOutput {
	return i.ToApplicationScopeMapOutputWithContext(context.Background())
}

func (i ApplicationScopeMap) ToApplicationScopeMapOutputWithContext(ctx context.Context) ApplicationScopeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationScopeMapOutput)
}

type ApplicationScopeOutput struct{ *pulumi.OutputState }

func (ApplicationScopeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationScope)(nil)).Elem()
}

func (o ApplicationScopeOutput) ToApplicationScopeOutput() ApplicationScopeOutput {
	return o
}

func (o ApplicationScopeOutput) ToApplicationScopeOutputWithContext(ctx context.Context) ApplicationScopeOutput {
	return o
}

type ApplicationScopeArrayOutput struct{ *pulumi.OutputState }

func (ApplicationScopeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationScope)(nil)).Elem()
}

func (o ApplicationScopeArrayOutput) ToApplicationScopeArrayOutput() ApplicationScopeArrayOutput {
	return o
}

func (o ApplicationScopeArrayOutput) ToApplicationScopeArrayOutputWithContext(ctx context.Context) ApplicationScopeArrayOutput {
	return o
}

func (o ApplicationScopeArrayOutput) Index(i pulumi.IntInput) ApplicationScopeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApplicationScope {
		return vs[0].([]*ApplicationScope)[vs[1].(int)]
	}).(ApplicationScopeOutput)
}

type ApplicationScopeMapOutput struct{ *pulumi.OutputState }

func (ApplicationScopeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationScope)(nil)).Elem()
}

func (o ApplicationScopeMapOutput) ToApplicationScopeMapOutput() ApplicationScopeMapOutput {
	return o
}

func (o ApplicationScopeMapOutput) ToApplicationScopeMapOutputWithContext(ctx context.Context) ApplicationScopeMapOutput {
	return o
}

func (o ApplicationScopeMapOutput) MapIndex(k pulumi.StringInput) ApplicationScopeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApplicationScope {
		return vs[0].(map[string]*ApplicationScope)[vs[1].(string)]
	}).(ApplicationScopeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationScopeInput)(nil)).Elem(), &ApplicationScope{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationScopeArrayInput)(nil)).Elem(), ApplicationScopeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationScopeMapInput)(nil)).Elem(), ApplicationScopeMap{})
	pulumi.RegisterOutputType(ApplicationScopeOutput{})
	pulumi.RegisterOutputType(ApplicationScopeArrayOutput{})
	pulumi.RegisterOutputType(ApplicationScopeMapOutput{})
}
